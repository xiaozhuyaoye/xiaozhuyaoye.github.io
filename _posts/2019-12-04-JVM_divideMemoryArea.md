---
layout: post
title: JVM 中内存区域的划分以及每个区域可能产生的异常
date:  2019-12-4
img:  /20191204/0.jpg
tags: [Java Virtual Machine]
author:  Taylor Toby
---



Java 虚拟机在执行 Java 程序的时候，会把管理的内存划分为不同的数据区域。每个区域有不同的用途和生命周期。

根据《Java 虚拟机规范（Java SE 7 版）》的规定，Java 虚拟机管理的内存区域包含以下几个部分，如图所示。

![](G:\xiaozhuyaoye.github.io\assets\img\20191204\640.jpg)



### 程序计数器 Program Counter Register

- 是什么

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

如果线程正在执行的是一个 Java 方法，则记录的是正在执行的虚拟机字节码指令地址。如果正在执行的是 Native 方法，则计数器值为空。

- 作用域

每个线程都有一个独立的程序计数器，互不影响。

- 会有哪些异常

虚拟机规范中对该区域没有规定任何 OutOfMemoryError 。



### Java 虚拟机栈 Java Virtual Machine Stack

- 是什么

虚拟机栈是用来描述 Java 方法执行的内存模型，每个方法在执行的时候会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从调用到执行结束的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

局部变量表中存放了编译期可知的基本数据类型，对象引用和 returnAddress 类型的数据。其中，64位长度的 long 和 double 类型的数据会占用两个局部变量空间，其余的数据类型只占用一个局部变量空间。局部变量表所需的空间在编译期间分配完成，当进入一个方法时，**这个方法需要在帧中分配多大的局部变量空间是完全确定的**，在方法**运行期间不会改变局部变量表的大小**。

- 作用域

生命周期与线程相同，是线程私有的。

- 会有哪些异常

如果线程请求的栈深度大于虚拟机所允许的深度，抛出 StackOverFlowError。

如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，抛出 OutOfMemoryError。



### 本地方法栈 Native Method Stack

- 是什么

与虚拟机栈十分类似，虚拟机栈是为 Java 方法服务，本地方法栈为虚拟机使用到的 Native 方法服务。

在虚拟机规范中没有对本地方法栈中使用的语言、使用方式、数据结构等进行规定，所以具体的虚拟机可以自由实现，甚至部分虚拟机直接把本地方法栈和虚拟机栈合二为一。

- 作用域

与虚拟机栈一样

- 会有哪些异常

与虚拟机栈一样



### Java 堆 Java Heap

- 是什么

在虚拟机启动时创建，用于存放对象实例，几乎所有的对象都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，为了方便内存回收，可以从多个角度对其进行分区，比如新生代和老年代。

根据虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。

- 作用域

所有线程共享

- 会有哪些异常

申请不到内存来分配实例，且无法再扩展时，抛出 OutOfMemoryError



### 方法区 Method Area

- 是什么

一块用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域。

虚拟机规范对这款区域的限制比较宽松，可以选择不实现垃圾收集，因为这部分的内存回收目标主要是针对常量池的回收和对类型的卸载，回收的条件很苛刻，效果难以令人满意。

HotSpot 虚拟机，使用堆内存的永久代来实现方法区，在 JDK 1.7 中，已经把字符串常量池从方法区中移到堆中。JDK 1.8 中，方法区使用元空间实现

- 作用域

所有线程共享

- 会有哪些异常

无法满足内存分配需求时，抛出 OutOfMemoryError



### 运行时常量池 Runtime Constant Pool

- 是什么

是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，也会将翻译出来的直接引用存储在运行时常量池中。

运行时常量池的另一个特点是具有动态性，运行期间也可以将新的常量放入池中。

- 作用域

所有线程共享

- 会有哪些异常

与方法区一致



### 直接内存 Direct Memory

- 是什么

不是虚拟机规范中定义的内存区域，对象分配在虚拟机堆以外的内存，由操作系统而不是虚拟机管理。可以提高复制速度，进而提高 IO 效率。

- 会有哪些异常

受到本机总内存大小以及处理器寻址空间的限制，当无法满足内存分配需求时，抛出 OutOfMemoryError 。