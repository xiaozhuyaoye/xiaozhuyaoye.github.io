---
layout: post
title: HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的过程
date:  2019-12-9
img:  /20191204/0.jpg
tags: [Java Virtual Machine]
author:  Taylor Toby
---



### 对象创建的过程



1. 当虚拟机执行一条 new 指令时，首先检查指令的参数，能否在常量池中定位到一个类的符号引用，如果定位到了，就检查所代表的类是否被加载、解析和初始化过。如果没有，就需要先执行类加载的过程。

2. 在类加载检查通过后，虚拟机为新生对象分配内存，对象所需要的内存大小在类加载完成后便完全确定了，为对象分配内存就是把一块确定大小的内存从 Java 堆中划分出来。

3. 内存分配完成后，虚拟机需要将分配到的内存全部初始化为零值（不包括对象头）。这步操作，是为了字段在不赋值的时候也能使用，程序能访问到字段所对应类型的零值。

4. 接着，虚拟机对对象进行必要的设置，比如这个对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头（Object Header）中，根据虚拟机当前的运行状态（比如是否启用偏向锁等），对象头会有不同的设置方式。

5. 最后，执行 init 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象就产生了。


###### 内存如何划分


在为对象分配内存时，需要将一个确定大小的内存从 Java 堆中划分出来。堆内存可能是规整的，也可能是不规整的。

规整的内存是指，用过的内存放在一边，未使用的内存放在另一边，中间放着一个指针作为分界点的指示器。这种分配方式叫做指针碰撞（Bump the Pointer）。使用指针碰撞的情况下分配新的内存，就是将指针向未使用的内存那边移动跟对象的大小一样的距离。

不规整的内存是指，用过的内存和未使用的内存互相交替，此时虚拟机会维护一个列表，用来记录哪些内存是可用的。这种分配方式叫做空闲列表（Free List）。使用空闲列表的情况下分配新的内存，需要从列表中找到一块足够大的内存，并更新列表上的记录。

具体采用哪种分配方式，是由堆内存是否规整决定，而堆内存是否规整由所采用的垃圾收集器是否带有压缩整理功能决定，比如 Serial、Compact 收集器采用指针碰撞的方式，CMS 收集器使用空闲列表的方式。



###### 内存划分时的并发问题



虚拟机中对象的创建十分频繁，所以划分内存是线程不安全的。比如正在给对象 A 分配内存，指针还没来得及修改，对象 B 又用原来的指针位置进行内存的划分。这个问题有两种解决方案：

---
1. 对内存分配动作进行同步，虚拟机是采用 CAS 并配上失败重试的方式保证原子性的。
2. 事先给每个线程划分一块内存区域，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），每个线程的内存分配都在这块区域内进行，只有在 TLAB 使用完需要分配新的内存的时候才需要进行同步。虚拟机是否使用 TLAB 可以通过参数 -XX:+/-UseTLAB 控制
---

### 对象在内存中的布局

在 HotSpot 虚拟机中，对象的存储布局可以分为 3 部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。



###### 对象头包含哪些信息



1. Mark World

Mark World 其实是对象自身在运行时期的数据，比如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。在 32 位和 64 位虚拟机中，Mark World 的大小分别是 32bit 和 64 bit，而要存储的数据非常多，远超过这个大小，所以 Mark World 被设计成一个非固定的数据结构来提高空间的利用率。

| 存储内容                     | 标志位 | 状态       |
| ---------------------------- | ------ | ---------- |
| 哈希码、分代年龄             | 01     | 未锁定     |
| 指向锁记录的指针             | 00     | 轻量级锁定 |
| 指向重量级锁的指针           | 10     | 重量级锁定 |
| 空                           | 11     | GC 标记    |
| 偏向线程ID和时间戳、分代年龄 | 01     | 可偏向     |

2. 类元数据

虚拟机通过这个指针来确定对象是哪个类的实例。

3. 数组长度

虚拟机可以通过普通 Java 对象的元数据确定对象的大小，但是从数组的元数据没法确定数组的大小，所以如果是数组对象，头中需要有这个信息。

###### 实例数据中有什么以及对其填充的作用

实例数据是对象存储的真正的有效信息，包括从父类中继承的属性和子类中定义的属性。属性存储的顺序，HotSpot 虚拟机中默认的是 long/double、int、short/char、byte/boolean、oops（Ordinary Object Pointer）。相同宽度的字段被分配到一起，如果两个属性类型的宽度一样，那么父类中定义的变量在子类之前，如果 CompactFiles 值为 true（默认），那么子类中较窄的变量会存储到父类较宽的变量之前。

对齐填充不是必然存在的，也没什么含义，仅仅是因为虚拟机的自动内存管理系统要求对象的起始地址必须是 8 的整数倍，也就是对象大小必须是 8 的整数倍。对象头满足这个条件，所以当实例数据没有对齐时，会通过对齐填充进行补全。



### 对象的访问定位



我们在程序中使用对象，通过栈上的 reference 数据来操作堆上的具体对象。虚拟机规范中只定义了 reference 类型是指向对象的引用，并没有规定这个引用应该通过何种方式去定位和访问对象的具体位置，所以对象的访问方式，不同的虚拟机实现可能是不同的。目前主流的访问方式有两种，通过句柄和直接指针。



如果使用句柄来访问对象，那么会在 Java 堆中划分出一块内存作为句柄池，reference 对象中存储的就是对象句柄的地址，句柄中包含了对象的实例数据地址和类型数据的地址。示例图如下

![](G:\xiaozhuyaoye.github.io\assets\img\20191209\0.png)



使用句柄来访问的好处是，reference 对象中存储的是稳定的句柄的地址，就算对象的实例数据被移动，也不需要改变 reference 对象的值，只需要改变句柄中的指向。



如果使用直接地址来访问对象，那么堆中的对象就需要存储对象类型数据的地址，如下图所示

![](G:\xiaozhuyaoye.github.io\assets\img\20191209\1.png)



使用直接地址访问的好处是速度更快，它节省了一次指针定位的时间开销。HotSpot 虚拟机就是使用这种方式来访问数据的。